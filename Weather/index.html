<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pro Weather ‚Äì Full-Stacky Frontend (Risk-Aware)</title>

  <!-- Bootstrap 5 -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Leaflet (Map) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      --bg: #01040c;
      --card: #d1dde2;
      --text: #0fbe21;
      --muted: #0a0101;
      --accent: #15b7ed;
      --low: #2ecc71;
      --med: #f39c12;
      --high: #e74c3c;
    }
    body{ background: var(--bg); color: var(--text); }
    .navbar{ background: linear-gradient(90deg, #1932a1, #ded00c); }
    .brand-accent{ color: var(--accent); }
    .card{ background: var(--card); border: 1px solid rgba(222, 14, 14, 0.06); box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .badge-soft{ background: #0a95d626; color: var(--accent); }
    .muted{ color: var(--muted); }
    #map{ height: 420px; border-radius: 16px; }
    .cursor-pointer{ cursor:pointer; }
    .minw-110{ min-width:110px; }
    .scroll-x{ overflow-x:auto; }
    .list-group-item{ background: transparent; color: var(--text); border-color: rgba(255, 255, 255, 0.08); }
    .form-control, .form-select{ background: #0e1325; color: var(--text); border-color: rgba(255,255,255,.12); }
    .form-control::placeholder{ color: #7e8bb3; }
    .btn-accent{ background: var(--accent); border: none; color: #03101a; font-weight:600; }
    .btn-accent:hover{ filter: brightness(1.05); }
    a, a:hover{ color: var(--accent); }
    canvas{ max-height: 260px; }
    .emoji-large{ font-size: 42px; line-height: 1; }
    .summary-row { gap: 1rem; align-items: center; display:flex; }
    .risk-bubble { width:12px; height:12px; border-radius:50%; display:inline-block; margin-right:6px; }
    .risk-low { background: var(--low); }
    .risk-med { background: var(--med); }
    .risk-high { background: var(--high); }
    .risk-card { min-height:120px; }
    #layerControls { position: absolute; right: 18px; top: 90px; z-index: 1100; }
  </style>
</head>
<body>
  <!-- Top Nav -->
  <nav class="navbar navbar-expand-lg navbar-dark sticky-top">
    <div class="container">
      <a class="navbar-brand fw-bold" href="#">
        Pro<span class="brand-accent">Weather</span>
      </a>
      <div class="d-flex gap-2 ms-auto">
        <button id="locBtn" class="btn btn-sm btn-accent">Use My Location</button>
        <button id="notifyBtn" class="btn btn-sm btn-outline-light">Enable Alerts</button>
      </div>
    </div>
  </nav>

  <main class="container my-4">
    <!-- Search + Units -->
    <div class="row g-3 align-items-end">
      <div class="col-md-6">
        <label class="form-label">Search city</label>
        <div class="input-group">
          <input id="searchInput" class="form-control" placeholder="e.g., Hyderabad, Mumbai, Delhi" />
          <button id="searchBtn" class="btn btn-accent">Search</button>
        </div>
        <div id="searchHints" class="small muted mt-2"></div>
      </div>
      <div class="col-md-3">
        <label class="form-label">Units</label>
        <select id="unitSelect" class="form-select">
          <option value="metric" selected>Metric (¬∞C, m/s)</option>
          <option value="imperial">Imperial (¬∞F, mph)</option>
        </select>
      </div>
      <div class="col-md-3">
        <label class="form-label">Language</label>
        <select id="langSelect" class="form-select">
          <option value="en" selected>English</option>
          <option value="hi">Hindi</option>
          <option value="te">Telugu</option>
          <option value="ta">Tamil</option>
        </select>
      </div>
    </div>

    <!-- Map + Current + Risk Summary -->
    <div class="row g-4 mt-1">
      <div class="col-lg-7 position-relative">
        <div id="layerControls" class="card p-2">
          <div class="form-check">
            <input class="form-check-input" type="checkbox" value="" id="toggleRiskLayer" checked>
            <label class="form-check-label muted" for="toggleRiskLayer">Show risk layer</label>
          </div>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" value="" id="toggleSensors">
            <label class="form-check-label muted" for="toggleSensors">Show sensors (if available)</label>
          </div>
        </div>

        <div class="card p-3">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 class="mb-0">Interactive Map</h5>
            <span class="badge rounded-pill badge-soft">Click anywhere to get forecast</span>
          </div>
          <div id="map"></div>
          <div class="small muted mt-2">Tiles ¬© OpenStreetMap contributors</div>
        </div>
      </div>

      <div class="col-lg-5">
        <div class="card p-3 h-100">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h5 id="placeTitle" class="mb-0">Current Weather</h5>
            <span id="updatedAt" class="small muted"></span>
          </div>
          <div id="currentWrap" class="d-flex gap-3 align-items-center">
            <div class="display-4 fw-bold" id="currTemp">--</div>
            <div>
              <div class="summary-row">
                <div id="currEmoji" class="emoji-large">‚Äî</div>
                <div>
                  <div id="currSummary" class="fs-5">‚Äî</div>
                  <div class="small muted" id="currMeta">‚Äî</div>
                </div>
              </div>
            </div>
          </div>
          <hr/>
          <div class="row text-center mb-3">
            <div class="col">
              <div class="muted small">Wind</div>
              <div id="currWind" class="fw-semibold">‚Äî</div>
            </div>
            <div class="col">
              <div class="muted small">Humidity</div>
              <div id="currHum" class="fw-semibold">‚Äî</div>
            </div>
            <div class="col">
              <div class="muted small">Precip</div>
              <div id="currPrec" class="fw-semibold">‚Äî</div>
            </div>
          </div>

          <!-- RISK CARDS -->
          <div class="d-flex gap-2">
            <div id="floodCard" class="card p-2 risk-card w-100">
              <div class="d-flex justify-content-between align-items-start">
                <div>
                  <div class="small muted">üåä Flood Risk</div>
                  <div id="floodLevel" class="fw-bold fs-5">‚Äî</div>
                  <div id="floodConf" class="small muted">Confidence ‚Äî</div>
                </div>
                <div class="text-end">
                  <div id="floodEmoji" style="font-size:28px">‚Äî</div>
                </div>
              </div>
              <div id="floodAction" class="mt-2 small muted">‚Äî</div>
            </div>

            <div id="heatCard" class="card p-2 risk-card w-100">
              <div class="d-flex justify-content-between align-items-start">
                <div>
                  <div class="small muted">‚òÄÔ∏è Heatwave Risk</div>
                  <div id="heatLevel" class="fw-bold fs-5">‚Äî</div>
                  <div id="heatConf" class="small muted">Confidence ‚Äî</div>
                </div>
                <div class="text-end">
                  <div id="heatEmoji" style="font-size:28px">‚Äî</div>
                </div>
              </div>
              <div id="heatAction" class="mt-2 small muted">‚Äî</div>
            </div>

            <div id="airCard" class="card p-2 risk-card w-100">
              <div class="d-flex justify-content-between align-items-start">
                <div>
                  <div class="small muted">üå´ Air Pollution</div>
                  <div id="airLevel" class="fw-bold fs-5">‚Äî</div>
                  <div id="airConf" class="small muted">Confidence ‚Äî</div>
                </div>
                <div class="text-end">
                  <div id="airEmoji" style="font-size:28px">‚Äî</div>
                </div>
              </div>
              <div id="airAction" class="mt-2 small muted">‚Äî</div>
            </div>
          </div>

        </div>
      </div>
    </div>

    <!-- Alerts -->
    <div id="alertsCard" class="card p-3 mt-4 d-none">
      <div class="d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Weather Alerts</h5>
        <span id="alertsCount" class="badge rounded-pill bg-danger">0</span>
      </div>
      <div id="alertsList" class="list-group list-group-flush mt-2"></div>
    </div>

    <!-- Hourly --> 
    <div class="card p-3 mt-4">
      <div class="d-flex justify-content-between align-items-center">
        <h5 class="mb-0">Next 24 Hours</h5>
        <div class="small muted" id="hoursNote">temperature</div>
      </div>
      <canvas id="hoursChart" aria-label="Hourly temperature"></canvas>
      <div class="small muted mt-2">Scroll map or click a new location to refresh.</div>
    </div>

    <!-- Daily -->
    <div class="card p-3 mt-4">
      <h5 class="mb-3">7-Day Forecast</h5>
      <div id="daysRow" class="d-flex gap-3 scroll-x"></div>
    </div>

    <!-- Footer -->
    <div class="text-center muted mt-4 mb-5 small">
      Built with Open-Meteo APIs, Leaflet, Bootstrap. No API key required.
    </div>
  </main>

  <!-- Vendor scripts -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
  // ------------------------------
  // Utilities & Config (extended)
  // ------------------------------
  const $ = (sel) => document.querySelector(sel);
  const fmt = (n, digits=0) => (n===null||n===undefined) ? "‚Äî" : Number(n).toFixed(digits);
  const storageKey = "proweather.cache.v1";
  const dayKey = () => new Date().toISOString().slice(0,10);
  let map, marker;
  let hoursChart;
  let riskLayerGroup = null;
  let sensorLayerGroup = null;

  // Helper nice color
  const riskColor = (r) => r === 'High' ? 'var(--high)' : (r === 'Medium' ? 'var(--med)' : 'var(--low)');

  // Units mapping
  function unitConfig(mode){
    if(mode==='imperial'){
      return { tempUnit: 'fahrenheit', windUnit: 'mph' };
    }
    return { tempUnit: 'celsius', windUnit: 'ms' };
  }

  // ------------------------------
  // Simple client-side provisional risk scorer
  // (DEM O only). Replace with backend ML for production!
  // Input: forecast (open-meteo), recentHourly (subset), sensors obj
  // Output: { flood: {level, confidence, score}, heat: {...}, air: {...} }
  // ------------------------------
  function provisionalRiskScore({ forecast, recentHourly = null, sensors = null }){
    // A basic heuristic: scores range 0-1
    // Flood: recent rain accumulation + precip probability + optional soil moisture sensor
    let floodScore = 0;
    try{
      // sum of precipitation_1h across last 6 hours from hourly (fallback)
      const hourly = forecast.hourly || {};
      const now = Date.now();
      const last24 = [];
      if(hourly.time){
        for(let i=0;i<hourly.time.length;i++){
          const t = new Date(hourly.time[i]).getTime();
          if(t >= now - (24*3600*1000) && t <= now){
            last24.push({ t, prec: hourly.precipitation_probability ? hourly.precipitation_probability[i] : 0, rain: hourly.precipitation ? hourly.precipitation[i] || 0 : 0 });
          }
        }
      }
      // approximate recent rainfall (mm) using precipitation_probability * proxy (demo)
      const recent = last24.slice(-6);
      const recentRainProxy = recent.reduce((s,p) => s + (p.rain || 0) , 0);
      // sensor soil moisture (0-1) if provided
      let soilFactor = 0;
      if(sensors && sensors.soil_moisture !== undefined){
        // sensors.soil_moisture: 0-1 where 1 = saturated
        soilFactor = sensors.soil_moisture;
      }
      floodScore = Math.min(1, (recentRainProxy / 100) + (soilFactor*0.6));
      // bump if high forecasted precip probability for next 12h
      if(forecast.hourly && forecast.hourly.precipitation_probability){
        const next12 = [];
        for(let i=0;i<forecast.hourly.time.length;i++){
          const t = new Date(forecast.hourly.time[i]).getTime();
          if(t > now && t <= now + 12*3600*1000) next12.push(forecast.hourly.precipitation_probability[i] || 0);
        }
        const avgNext12 = next12.length? next12.reduce((a,b)=>a+b,0)/next12.length : 0;
        floodScore = Math.min(1, floodScore + (avgNext12/200)); // small bump
      }
    }catch(e){ console.warn('Flood scoring err', e); floodScore = 0; }

    // Heatwave: high daytime temps + humidity
    let heatScore = 0;
    try{
      const daily = forecast.daily || {};
      // compare today's max to historical thresholds (simple demo)
      const todayMax = daily.temperature_2m_max ? daily.temperature_2m_max[0] : null;
      const todayHum = (forecast.hourly && forecast.hourly.relative_humidity_2m) ? (() => {
        const nowH = new Date().toISOString().slice(0,13);
        const idx = forecast.hourly.time ? forecast.hourly.time.findIndex(t=>t.startsWith(nowH)) : -1;
        if(idx>=0) return forecast.hourly.relative_humidity_2m[idx]; return null;
      })() : null;
      if(todayMax !== null){
        // thresholds: >40C high, 35-40 medium (metric). In imperial adjust later.
        const units = $('#unitSelect').value;
        const tVal = Number(todayMax);
        const threshHigh = (units==='imperial') ? 104 : 40;
        const threshMed = (units==='imperial') ? 95 : 35;
        if(tVal >= threshHigh) heatScore = 1;
        else if(tVal >= threshMed) heatScore = 0.6;
        else heatScore = Math.max(0, (tVal - (threshMed-5)) / (threshHigh - (threshMed-5)));
        // boost if high humidity
        if(todayHum) heatScore = Math.min(1, heatScore + (todayHum/200));
      }
    }catch(e){ console.warn('Heat scoring err', e); heatScore = 0; }

    // Air pollution: use sensors.AQI or fallback to backend data if available
    let airScore = 0;
    let aqiValue = null;
    try{
      if(sensors && sensors.aqi !== undefined){
        aqiValue = sensors.aqi;
      } else if(forecast.hourly && forecast.hourly.aqi){ // if API provides it
        // note: most free endpoints don't give AQI; placeholder
        aqiValue = forecast.hourly.aqi[0];
      }
      if(aqiValue !== null && aqiValue !== undefined){
        // AQI scale (0-500) ‚Äî map to 0-1
        airScore = Math.min(1, aqiValue / 300);
      } else {
        // fallback heuristic: high particulate precipitation + low wind -> worse dispersion
        const next12wind = (forecast.hourly && forecast.hourly.wind_speed_10m) ? (() => {
          const now = Date.now();
          const arr = [];
          for(let i=0;i<forecast.hourly.time.length;i++){
            const t = new Date(forecast.hourly.time[i]).getTime();
            if(t > now && t <= now + 12*3600*1000) arr.push(forecast.hourly.wind_speed_10m[i] || 0);
          }
          return arr.length ? arr.reduce((a,b)=>a+b,0)/arr.length : 3;
        })() : 3;
        // less wind increases score
        airScore = Math.max(0, 1 - Math.min(1, next12wind/10));
      }
    }catch(e){ console.warn('Air scoring err', e); airScore = 0; }

    // Convert to labels
    function labelFromScore(s){
      if(s >= 0.7) return 'High';
      if(s >= 0.35) return 'Medium';
      return 'Low';
    }
    return {
      flood: { score: floodScore, level: labelFromScore(floodScore), confidence: Math.round((0.5 + floodScore*0.5)*100) },
      heat:  { score: heatScore,  level: labelFromScore(heatScore),  confidence: Math.round((0.6 + heatScore*0.4)*100) },
      air:   { score: airScore,   level: labelFromScore(airScore),   confidence: Math.round((0.4 + airScore*0.6)*100) }
    };
  }

  // ------------------------------
  // Map initialization & risk layer helpers
  // ------------------------------
  function initMap(){
    map = L.map('map', { zoomControl: true }).setView([17.3850, 78.4867], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap' }).addTo(map);
    marker = L.marker([17.3850, 78.4867], { draggable:false }).addTo(map);

    riskLayerGroup = L.layerGroup().addTo(map);
    sensorLayerGroup = L.layerGroup().addTo(map);

    map.on('click', async (e) => {
      const { lat, lng } = e.latlng;
      marker.setLatLng([lat, lng]);
      await handleForecastByCoords(lat, lng, null);
    });
  }

  function drawRiskMarker(lat, lon, riskObj){
    // riskObj: { flood:{level,score}, heat:{}, air:{} }
    const main = (riskObj.flood.score >= riskObj.heat.score && riskObj.flood.score >= riskObj.air.score) ? 'flood'
                : (riskObj.heat.score >= riskObj.air.score ? 'heat' : 'air');
    const level = riskObj[main].level;
    const color = riskColor(level);
    const circle = L.circleMarker([lat, lon], {
      radius: 12,
      color: color,
      fillColor: color,
      fillOpacity: 0.6,
      weight: 1
    }).bindPopup(`<b>Risk (summary)</b><br/>
      Flood: ${riskObj.flood.level} (${Math.round(riskObj.flood.score*100)}%)<br/>
      Heat: ${riskObj.heat.level} (${Math.round(riskObj.heat.score*100)}%)<br/>
      Air: ${riskObj.air.level} (${Math.round(riskObj.air.score*100)}%)`);
    riskLayerGroup.addLayer(circle);
  }

  function clearRiskLayer(){ riskLayerGroup.clearLayers(); }
  function clearSensorLayer(){ sensorLayerGroup.clearLayers(); }

  // ------------------------------
  // Geocoding / forecast / alerts (kept from original)
  // ------------------------------
  async function geocodeByName(q){
    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(q)}&count=5&language=${$('#langSelect').value}`;
    const res = await fetch(url);
    if(!res.ok) throw new Error('Geocoding failed');
    const data = await res.json();
    return data.results || [];
  }

  async function reverseLookup(lat, lon){
    const url = `https://geocoding-api.open-meteo.com/v1/reverse?latitude=${lat}&longitude=${lon}&language=${$('#langSelect').value}`;
    try{
      const res = await fetch(url);
      if(!res.ok) return null;
      const data = await res.json();
      const r = data?.results?.[0];
      if(!r) return null;
      return r.name + (r.admin1 ? ', ' + r.admin1 : '') + (r.country ? ', ' + r.country : '');
    }catch{ return null; }
  }

  async function fetchForecast(lat, lon){
    const units = unitConfig($('#unitSelect').value);
    const url = new URL('https://api.open-meteo.com/v1/forecast');
    const params = {
      latitude: lat, longitude: lon,
      current_weather: true,
      hourly: ['temperature_2m','relative_humidity_2m','precipitation_probability','precipitation','wind_speed_10m','weathercode'].join(','),
      daily: ['temperature_2m_max','temperature_2m_min','precipitation_sum','sunrise','sunset','weathercode'].join(','),
      temperature_unit: units.tempUnit,
      wind_speed_unit: units.windUnit,
      timezone: 'auto',
      forecast_days: 7
    };
    Object.keys(params).forEach(k => url.searchParams.set(k, params[k]));
    const res = await fetch(url);
    if(!res.ok) throw new Error('Forecast failed');
    return await res.json();
  }

  async function fetchAlerts(lat, lon){
    const url = new URL('https://api.open-meteo.com/v1/warnings');
    url.searchParams.set('latitude', lat);
    url.searchParams.set('longitude', lon);
    url.searchParams.set('timezone', 'auto');
    url.searchParams.set('past_days', 0);
    const res = await fetch(url);
    if(!res.ok) return { warnings: [] };
    return await res.json();
  }

  // ------------------------------
  // Sensors & IoT (placeholders)
  // - In production, your backend should expose /api/sensors/latest?lat=&lon=
  //   which returns nearest sensors: { aqi: 120, soil_moisture: 0.78, rainfall_mm_last_1h: 12, ... }
  // ------------------------------
  async function fetchNearbySensors(lat, lon){
    // DEMO: attempt a backend endpoint; if absent, return null to let provisional scoring use forecast
    try{
      const res = await fetch(`/api/sensors/latest?lat=${lat}&lon=${lon}`);
      if(!res.ok) return null;
      return await res.json();
    }catch(e){
      return null;
    }
  }

  // ------------------------------
  // Renderers (current, daily, hourly) - (kept largely same, small additions)
  // ------------------------------
  function renderCurrent(fullForecast, place){
    const cWeather = fullForecast.current_weather || {};
    const nowISO = new Date().toISOString().slice(0,16);
    const hourly = fullForecast.hourly || {};
    const idx = hourly.time ? hourly.time.findIndex(t => t.startsWith(new Date().toISOString().slice(0,13))) : -1;
    const temperature = cWeather.temperature ?? (idx>=0 ? hourly.temperature_2m[idx] : null);
    const wind = cWeather.windspeed ?? (idx>=0 ? hourly.wind_speed_10m[idx] : null);
    const weather_code = cWeather.weathercode ?? (idx>=0 ? hourly.weathercode[idx] : null);
    const humidity = (hourly.relative_humidity_2m && idx>=0) ? hourly.relative_humidity_2m[idx] : null;
    const precip = (hourly.precipitation_probability && idx>=0) ? hourly.precipitation_probability[idx] : null;
    const nightFlag = isNightNow(fullForecast);

    $('#placeTitle').textContent = place || 'Current Weather';
    $('#currTemp').textContent = (temperature !== null && temperature !== undefined) ? fmt(temperature,1) + '¬∞' : '‚Äî';
    $('#currSummary').textContent = weatherCodeToText(weather_code) || '‚Äî';
    $('#currEmoji').textContent = weatherCodeToEmoji(weather_code, nightFlag);
    const meta = `Humidity ${fmt(humidity)}% ‚Ä¢ Precip ${fmt(precip)}%`;
    $('#currMeta').textContent = meta;
    $('#currWind').textContent = fmt(wind,1) + ( $('#unitSelect').value==='imperial' ? ' mph' : ' m/s');
    $('#currHum').textContent = fmt(humidity) + '%';
    $('#currPrec').textContent = (precip!==null && precip!==undefined) ? fmt(precip,1) : '‚Äî';
    $('#updatedAt').textContent = 'Updated: ' + new Date().toLocaleString();
  }

  function renderDaily(fullForecast){
    const d = fullForecast.daily;
    const daysEl = $('#daysRow');
    daysEl.innerHTML = '';
    if(!d || !d.time) return;
    for(let i=0;i<d.time.length;i++){
      const day = new Date(d.time[i]);
      const weatherCode = d.weathercode ? d.weathercode[i] : null;
      const emoji = weatherCodeToEmoji(weatherCode, false);
      const card = document.createElement('div');
      card.className = 'card p-3 text-center minw-110';
      card.innerHTML = `
        <div class="fw-semibold">${day.toLocaleDateString(undefined, { weekday:'short' })}</div>
        <div class="muted small">${day.toLocaleDateString()}</div>
        <div class="display-6 fw-bold my-2">${fmt(d.temperature_2m_max[i],0)}¬∞</div>
        <div class="muted">Min ${fmt(d.temperature_2m_min[i],0)}¬∞</div>
        <div class="muted small mt-1">${emoji} ${weatherCodeToText(weatherCode)}</div>
      `;
      daysEl.appendChild(card);
    }
  }

  function renderHourlyChart(fullForecast){
    const h = fullForecast.hourly;
    if(!h || !h.time) return;
    const now = Date.now();
    const points = [];
    for(let i=0;i<h.time.length;i++){
      const t = new Date(h.time[i]).getTime();
      if(t >= now && points.length < 24){
        points.push({ t, temp: h.temperature_2m[i], code: h.weathercode ? h.weathercode[i] : null });
      }
    }
    const labels = points.map(p => new Date(p.t).toLocaleTimeString([], { hour:'2-digit', minute:'2-digit' }));
    const temps = points.map(p => p.temp);

    const ctx = document.getElementById('hoursChart');
    if(hoursChart){ hoursChart.destroy(); }
    hoursChart = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          label: 'Temperature (next 24h)',
          data: temps,
          tension: .35,
          fill: false,
          pointRadius: 3,
          borderWidth: 2
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => items[0].label,
              label: (ctx) => {
                const v = ctx.formattedValue;
                const idx = ctx.dataIndex;
                const code = points[idx]?.code;
                const emoji = weatherCodeToEmoji(code);
                return `${emoji} ${v}¬∞`;
              }
            },
            mode: 'index',
            intersect: false
          }
        },
        scales: {
          x: { ticks: { color: '#91a0c2' }, grid: { display:false }},
          y: { ticks: { color: '#91a0c2' }, grid: { color: 'rgba(255,255,255,.08)' } }
        }
      }
    });
  }

  function renderAlerts(alertData){
    const list = $('#alertsList');
    const wrap = $('#alertsCard');
    list.innerHTML = '';
    const alerts = alertData?.warnings || [];
    $('#alertsCount').textContent = alerts.length;
    if(alerts.length === 0){
      wrap.classList.add('d-none');
      return;
    }
    wrap.classList.remove('d-none');

    alerts.forEach(a => {
      const item = document.createElement('div');
      item.className = 'list-group-item';
      const starts = a.onset ? new Date(a.onset).toLocaleString() : '';
      const ends = a.expires ? new Date(a.expires).toLocaleString() : '';
      item.innerHTML = `
        <div class="d-flex justify-content-between">
          <div>
            <div class="fw-semibold">${a.event || 'Alert'}</div>
            <div class="small muted">${a.sender || ''}</div>
          </div>
          <span class="badge bg-danger">${a.severity || 'warning'}</span>
        </div>
        <div class="small mt-2">${(a.description || '').replace(/\n/g,'<br>')}</div>
        <div class="small muted mt-2">From: ${starts || '‚Äî'} &nbsp;|&nbsp; Until: ${ends || '‚Äî'}</div>
      `;
      list.appendChild(item);
    });
  }

  // ------------------------------
  // Put it together: handleForecastByCoords extended
  // ------------------------------
  async function handleForecastByCoords(lat, lon, placeOverride){
    $('#placeTitle').textContent = 'Loading‚Ä¶';
    clearRiskLayer();
    clearSensorLayer();

    const [forecast, alerts] = await Promise.all([ fetchForecast(lat, lon), fetchAlerts(lat, lon) ]);
    const place = placeOverride || await reverseLookup(lat, lon) || `Lat ${lat.toFixed(2)}, Lon ${lon.toFixed(2)}`;
    renderCurrent(forecast, place);
    renderDaily(forecast);
    renderHourlyChart(forecast);
    renderAlerts(alerts);

    // Fetch sensors (if your backend exposes them)
    const sensors = await fetchNearbySensors(lat, lon); // can be null
    if(sensors && $('#toggleSensors').checked){
      // Draw sensor markers (example)
      if(sensors.location){
        const m = L.marker([sensors.location.lat, sensors.location.lon], { title: 'Sensor' }).addTo(sensorLayerGroup);
        m.bindPopup(`<b>Sensor</b><br/>AQI: ${sensors.aqi ?? '‚Äî'}<br/>Soil moisture: ${sensors.soil_moisture ?? '‚Äî'}`);
      }
    }

    // Try calling production backend for ML predictions. If fails, fallback to provisional scoring
    let riskObj = null;
    try{
      // --- PRODUCTION HOOK ---
      // Your backend should implement POST /api/predict_risks and return:
      // { flood: { score:0-1, level:'Low|Medium|High', confidence: 0-100 },
      //   heat: {...}, air: {...} , meta: {...} }
      // Request shape (example):
      // { lat, lon, forecast: <open-meteo json>, sensors: {...} }
      const res = await fetch('/api/predict_risks', {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ lat, lon, forecast, sensors })
      });
      if(res.ok){
        const payload = await res.json();
        riskObj = payload;
      } else {
        // fallback
        riskObj = provisionalRiskScore({ forecast, sensors });
      }
    }catch(e){
      // offline or endpoint missing -> fallback
      riskObj = provisionalRiskScore({ forecast, sensors });
    }

    // Render risk cards
    $('#floodLevel').textContent = riskObj.flood.level;
    $('#floodConf').textContent = `Confidence ${riskObj.flood.confidence}%`;
    $('#floodEmoji').textContent = riskObj.flood.level === 'High' ? 'üåä' : (riskObj.flood.level==='Medium' ? 'üíß' : '‚úÖ');
    $('#floodAction').innerHTML = mitigationMessage('flood', riskObj.flood.level);

    $('#heatLevel').textContent = riskObj.heat.level;
    $('#heatConf').textContent = `Confidence ${riskObj.heat.confidence}%`;
    $('#heatEmoji').textContent = riskObj.heat.level === 'High' ? 'üî•' : (riskObj.heat.level==='Medium' ? '‚òÄÔ∏è' : 'üòå');
    $('#heatAction').innerHTML = mitigationMessage('heat', riskObj.heat.level);

    $('#airLevel').textContent = riskObj.air.level;
    $('#airConf').textContent = `Confidence ${riskObj.air.confidence}%`;
    $('#airEmoji').textContent = riskObj.air.level === 'High' ? 'üò∑' : (riskObj.air.level==='Medium' ? 'üò∂‚Äçüå´Ô∏è' : 'üå§Ô∏è');
    $('#airAction').innerHTML = mitigationMessage('air', riskObj.air.level);

    // Put a marker on map summarizing risk
    if($('#toggleRiskLayer').checked){
      drawRiskMarker(lat, lon, riskObj);
    }

    // Optionally send notifications (to backend or directly)
    if(riskObj.flood.level === 'High' || riskObj.heat.level === 'High' || riskObj.air.level === 'High'){
      // Show browser notification (if permission granted)
      if(Notification.permission === 'granted'){
        new Notification(`High risk: ${place}`, { body: `Flood: ${riskObj.flood.level}, Heat: ${riskObj.heat.level}, Air: ${riskObj.air.level}` });
      }
      // TODO: POST to /api/notify to push SMS/WhatsApp/email via backend (Twilio/WhatsApp Cloud/API)
      // Example (do this server-side):
      // POST /api/notify { channels:['sms','whatsapp'], message: 'High Flood Risk in Ward 23...', recipients:[...], meta:{lat,lon} }
    }

    // Save to cache (optional)
    writeCache({ lat, lon, place, forecast, alerts, riskObj, cachedAt: Date.now() });
    $('#updatedAt').textContent = 'Updated: ' + new Date().toLocaleString();
  }

  // Mitigation messages
  function mitigationMessage(type, level){
    if(type==='flood'){
      if(level==='High') return `<b>Actions:</b> Prepare sandbags, move valuables to higher floors, avoid travel in low-lying roads. Contact local authorities if water enters homes.`;
      if(level==='Medium') return `<b>Actions:</b> Clear drains, secure small valuables, avoid parking in low areas. Monitor updates.`;
      return `<b>Actions:</b> Normal ‚Äî drains clear, but stay alert during heavy rain.`;
    }
    if(type==='heat'){
      if(level==='High') return `<b>Actions:</b> Use cooling centers, avoid outdoor work between 11am-4pm, hydrate, check on elderly/children.`;
      if(level==='Medium') return `<b>Actions:</b> Hydrate, plan outdoor activity for mornings/evenings, wear light clothing.`;
      return `<b>Actions:</b> Normal ‚Äî typical conditions.`;
    }
    if(type==='air'){
      if(level==='High') return `<b>Actions:</b> Avoid outdoor exercise, wear N95 if needed, close windows, use clean-air shelters for sensitive groups.`;
      if(level==='Medium') return `<b>Actions:</b> Sensitive groups avoid heavy exertion outdoors; consider masks.`;
      return `<b>Actions:</b> Normal air quality.`;
    }
    return '';
  }

  // ------------------------------
  // Cache helpers (unchanged)
  // ------------------------------
  function readCache(){
    try{
      const raw = localStorage.getItem(storageKey);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(obj?.day !== dayKey()) return null;
      return obj;
    }catch{ return null; }
  }
  function writeCache(payload){
    const obj = { day: dayKey(), ...payload };
    localStorage.setItem(storageKey, JSON.stringify(obj));
  }

  // ------------------------------
  // Weather code helpers (unchanged)
  // ------------------------------
  function weatherCodeToText(code){
    const map = {
      0:'Clear sky',1:'Mainly clear',2:'Partly cloudy',3:'Overcast',45:'Fog',48:'Depositing rime fog',
      51:'Light drizzle',53:'Drizzle',55:'Dense drizzle',56:'Freezing drizzle',57:'Dense freezing drizzle',
      61:'Slight rain',63:'Rain',65:'Heavy rain',66:'Freezing rain',67:'Heavy freezing rain',
      71:'Slight snow fall',73:'Snow fall',75:'Heavy snow fall',77:'Snow grains',
      80:'Slight rain showers',81:'Moderate rain showers',82:'Violent rain showers',
      85:'Slight snow showers',86:'Heavy snow showers',95:'Thunderstorm',96:'Thunderstorm with slight hail',99:'Thunderstorm with heavy hail'
    };
    return map[code] || 'Unknown';
  }
  function weatherCodeToEmoji(code, isNight=false){
    if(code === 0) return isNight ? 'üåô' : '‚òÄÔ∏è';
    if(code === 1) return isNight ? 'üåô' : 'üå§Ô∏è';
    if(code === 2) return '‚õÖ';
    if(code === 3) return '‚òÅÔ∏è';
    if([45,48].includes(code)) return 'üå´Ô∏è';
    if([51,53,55,56,57].includes(code)) return 'üå¶Ô∏è';
    if([61,63,65,80,81,82].includes(code)) return 'üåßÔ∏è';
    if([66,67].includes(code)) return 'üßäüåßÔ∏è';
    if([71,73,75,77,85,86].includes(code)) return '‚ùÑÔ∏è';
    if([95,96,99].includes(code)) return 'üå©Ô∏è';
    return 'üå°Ô∏è';
  }
  function isNightNow(forecast){
    try{
      const now = new Date();
      const sr = forecast?.daily?.sunrise?.[0];
      const ss = forecast?.daily?.sunset?.[0];
      if(!sr || !ss) return false;
      const sunrise = new Date(sr);
      const sunset = new Date(ss);
      return (now < sunrise) || (now >= sunset);
    }catch{return false;}
  }

  // ------------------------------
  // Geo-locate & fallback (unchanged except using new handler)
  // ------------------------------
 async function useGeolocation(){
  if(!navigator.geolocation){
    alert('Geolocation not supported. Using IP-based location.');
    return fallbackByIP();
  }
  navigator.geolocation.getCurrentPosition(async (pos) => {
    const { latitude, longitude } = pos.coords;
    map.setView([latitude, longitude], 10);
    marker.setLatLng([latitude, longitude]);
    await handleForecastByCoords(latitude, longitude, null);
  }, async (err) => {
    console.warn("Geolocation error:", err.message);
    if(err.code === err.PERMISSION_DENIED){
      alert("Permission denied. Using IP-based location instead.");
      return fallbackByIP();
    }
    if(err.code === err.TIMEOUT){
      alert("Timeout. Retrying with low accuracy...");
      navigator.geolocation.getCurrentPosition(async (pos) => {
        const { latitude, longitude } = pos.coords;
        map.setView([latitude, longitude], 10);
        marker.setLatLng([latitude, longitude]);
        await handleForecastByCoords(latitude, longitude, null);
      }, () => {
        alert("Still failed. Falling back to IP location.");
        fallbackByIP();
      }, { enableHighAccuracy: false, timeout: 20000 });
    } else {
      alert("Location failed. Using IP-based location.");
      fallbackByIP();
    }
  }, { enableHighAccuracy: true, timeout: 10000 });
}

  async function fallbackByIP(){
    try{
      const res = await fetch("https://ipapi.co/json/");
      const data = await res.json();
      if(data && data.latitude && data.longitude){
        setLocation(data.latitude, data.longitude, data.city + ", " + data.country_name);
      } else {
        return fallbackByIP2();
      }
    }catch(e){
      return fallbackByIP2();
    }
  }
  async function fallbackByIP2(){
    try{
      const res = await fetch("https://ipwho.is/");
      const data = await res.json();
      if(data && data.latitude && data.longitude){
        setLocation(data.latitude, data.longitude, data.city + ", " + data.country);
      } else {
        alert("Could not detect location. Please search manually.");
      }
    }catch(e){
      alert("Could not detect location. Please search manually.");
    }
  }
  async function setLocation(lat, lon, label){
    map.setView([lat, lon], 8);
    marker.setLatLng([lat, lon]);
    await handleForecastByCoords(lat, lon, label);
  }

  // Search
  async function doSearch(){
    const q = $('#searchInput').value.trim();
    if(!q) return;
    $('#searchHints').textContent = 'Searching‚Ä¶';
    try{
      const results = await geocodeByName(q);
      if(results.length === 0){
        $('#searchHints').textContent = 'No matches. Try a different name.';
        return;
      }
      $('#searchHints').innerHTML = results.map(r => `
        <span class="badge rounded-pill bg-secondary cursor-pointer me-2 mb-2"
              data-lat="${r.latitude}" data-lon="${r.longitude}"
              title="Click to load">${r.name}${r.admin1?', '+r.admin1:''}${r.country?', '+r.country:''}</span>
      `).join('');
      document.querySelectorAll('#searchHints .badge').forEach(el => {
        el.addEventListener('click', async () => {
          const lat = parseFloat(el.getAttribute('data-lat'));
          const lon = parseFloat(el.getAttribute('data-lon'));
          const place = el.textContent;
          map.setView([lat, lon], 10);
          marker.setLatLng([lat, lon]);
          await handleForecastByCoords(lat, lon, place);
        });
      });
    }catch(e){
      $('#searchHints').textContent = 'Search error. Try again.';
    }
  }

  // Notifications
  $('#notifyBtn')?.addEventListener('click', async () => {
    if(!('Notification' in window)) return alert('Notifications not supported.');
    const p = await Notification.requestPermission();
    if(p==='granted') alert('Alerts enabled. We will notify when warnings appear.');
  });

  // Unit or language change -> re-fetch current marker point
  async function refreshFromMarker(){
    const { lat, lng } = marker.getLatLng();
    await handleForecastByCoords(lat, lng, $('#placeTitle').textContent);
  }

  // Wiring
  window.addEventListener('DOMContentLoaded', async () => {
    initMap();
    const cache = readCache();
    if(cache){
      map.setView([cache.lat, cache.lon], 10);
      marker.setLatLng([cache.lat, cache.lon]);
      renderCurrent(cache.forecast, cache.place);
      renderDaily(cache.forecast);
      renderHourlyChart(cache.forecast);
      renderAlerts(cache.alerts);
      $('#updatedAt').textContent = 'From cache: ' + new Date(cache.cachedAt).toLocaleString();
    }else{
      useGeolocation();
    }

    $('#locBtn').addEventListener('click', useGeolocation);
    $('#searchBtn').addEventListener('click', doSearch);
    $('#searchInput').addEventListener('keydown', (e) => { if(e.key==='Enter') doSearch(); });
    $('#unitSelect').addEventListener('change', refreshFromMarker);
    $('#langSelect').addEventListener('change', refreshFromMarker);

    // Risk layer toggle
    $('#toggleRiskLayer').addEventListener('change', (e) => {
      if(e.target.checked) riskLayerGroup.addTo(map); else map.removeLayer(riskLayerGroup);
    });
    $('#toggleSensors').addEventListener('change', (e) => {
      if(e.target.checked) sensorLayerGroup.addTo(map); else map.removeLayer(sensorLayerGroup);
    });
  });
  </script>
</body>
</html>
